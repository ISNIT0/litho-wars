'use strict';

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _util = require('util');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = (0, _util.debuglog)('metalsmith-paths');

/**
 * @param {Object} options
 * @return {Function}
 */

module.exports = function plugin(options) {
  options = Object.assign({}, {
    property: 'path',
    directoryIndex: false,
    hrefIndex: false
  }, options);

  return function (files, metalsmith, done) {
    setImmediate(done);

    Object.keys(files).forEach(function (file) {
      debug('process file: %s', file);

      if (_path2.default.parse) {
        debug('[node >= 0.11.15] using path.parse');

        files[file][options.property] = _path2.default.parse(file);
      } else {
        // add file path info
        var extname = _path2.default.extname(file);

        files[file][options.property] = {
          base: _path2.default.basename(file),
          dir: _path2.default.dirname(file).split(_path2.default.sep).join('/'),
          ext: extname,
          name: _path2.default.basename(file, extname)
        };
      }

      // In some versions of node/path, 'dir' at root may be either '.' or empty
      // Normalize this property to be empty
      if (files[file][options.property].dir === '.') {
        files[file][options.property].dir = '';
      }

      // generate href
      var href = '/';

      if (files[file][options.property].dir && files[file][options.property].dir !== '.') {
        href += files[file][options.property].dir + '/';
      }

      var dhref = href;

      if (!options.directoryIndex || _path2.default.basename(file) !== options.directoryIndex) {
        href += _path2.default.basename(file);
      }

      files[file][options.property].href = href;
      files[file][options.property].dhref = dhref;
    });
  };
};